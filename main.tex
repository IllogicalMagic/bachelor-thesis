\documentclass[12pt,a4paper]{article}

\usepackage[top=2.0cm, bottom=2.0cm, left=3cm, right=1.5cm, footskip=0.5cm]{geometry}

\usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[T1,T2A]{fontenc}                    % Поддержка русских букв
\usepackage[utf8]{inputenc}[2014/04/30]         % Кодировка utf8
\usepackage[english, russian]{babel}[2014/03/24]% Языки: русский, английский
\usepackage{setspace}

\begin{document}

% Если содержание расползётся на две страницы
% \doublespacing
\tableofcontents
% \singlespacing
\newpage

\section{Вступление}

\indent

% TODO: add reference
Встраиваемые системы получают всё большее распространение в современном мире. Примеры их использования можно найти почти в любой области деятельности, начиная от промышленных систем, сложной техники с множеством подобных устройств, автомобилей и летательных аппаратов и заканчивая обычными персональными устройствами наподобие мобильных телефонов или бытовой техники. В последнее время также набирает популярность интернет вещей (``Internet of Things'', IOT) -- область, связанная с использованием большого количества постоянно обменивающихся между собой информацией вычислительных устройств в самых различных направлениях деятельности.

% TODO: add reference
Развитие области применения встраиваемых систем приводит к их постепенному усложнению, так как от таких устройств требуется всё больше функциональности. Необходимость расширения функционала приводит к потребности в увеличении производительности процессоров в таких системах, что влечёт за собой изменения в архитектуре и микроархитектуре, например, к добавлению кэшей и расширению набора инструкций. Таким образом процессоры в таких устройствах становятся всё более похожими на процессоры общего назначения, поэтому открываются новые возможности для оптимизации программного обеспечения, загружаемого во встраиваемые системы.

% TODO: add reference
Расширение функционала устройств также приводит к изменениям в программном обеспечении встроенных систем. Оно становится всё более сложным и ресурсоёмким. Растёт количество строк в проектах, появляется всё больше уровней абстракции. Ручная оптимизация постепенно теряет приоритет, уступая его непосредственно написанию и проектированию сложного кода. При этом усложнение архитектуры открывает возможности для новых оптимизаций, поэтому с учётом того, что во встраиваемых системах особенно ценны ресурсы процессора, появляется необходимость в автоматическом проведении оптимизаций над кодом, например, с помощью компилятора.

% TODO: add reference
Современные приложения, как для процессоров общего назначения, так и для встраиваемых систем, могут очень активно использовать память, при этом частота работы процессоров выше, чем частота работы оперативной памяти, что может повлечь за собой задежки при исполнении инструкций (проблема, известная как ``Memory wall''). Эффективным средством борьбы с ними являются кэши, но даже хорошо спроектированная многоуровневая иерархия кэшей не позволяет полностью избавиться от задержек. Промахи в кэш будут происходить как при первичных доступах к данным, так и просто при нерегулярном доступе в память (например, при обходе дерева, узлы которого выделены в куче).

% TODO: add reference
В качестве одного из решений данной проблемы можно привести поддержку компилятора, анализирующего доступы в память, и вставляющего специальные инструкции предподкачки данных в кэш. Однако при таком подходе встаёт вопрос о том, как определить, где действительно нужна трансформация, а где нет, так как сгенерированный код в последнем случае либо не делает никакой полезной работы, либо загрязняет кэш, что может приводить к ухудшению производительности. В случае же успешной предподкачки исполнение программ может значительно ускоряться, показывая хорошие результаты на различных классах приложений.

\newpage

\section{Цель работы}

\indent

Главной целью данного проекта является разработка машинно-независимой оптимизирующей трансформации предподкачки данных для циклов в открытой инфраструктуре компилятора LLVM. В рамках данной работы можно выделить пять основных частей, которые, в свою очередь, также охватывают несколько различных областей в соответствующих темах. Первые две составляющие являются исследовательской работой, остальное -- сама разработка и тестирование полученной фазы.

\paragraph{Исследование алгоритмов}

В данной части необходимо исследовать нескольких подходов для различных способов работы с памятью, таких как косвенные доступы и доступы к рекурсивным структурам данных, представляющим наибольший интерес ввиду отсутвия какой-либо регулярности при доступе в память.

\paragraph{Исследование компиляторов}

Вторая часть работы должна включать в себя исследование уже существующих решений в различных компиляторах на предмет их возможностей касательно данной оптимизации, а также возможности настройки поведения фаз.

\paragraph{Разработка фаз}

Третья часть -- непосредственно разработка комплексной трансформации, состоящей из четырёх отдельных подзадач:
\begin{itemize}
\item разработка фазы архитектурно-зависимой преаллокации (только для архитектуры ARC);
\item улучшение уже существующей фазы для предподкачки данных при регулярных доступах (\textbf{``stride accesses''}) -- добавление предподкачки перед циклом и возможности предподкачки во внешних циклах;
\item разработка фазы предподкачки данных для косвенных доступов (\textbf{``indirect accesses''});
\item разработка фазы предподкачки данных для доступов в рекурсивных структурах данных (\textbf{``recursive data structures''}, \textbf{``RDS''}).
\end{itemize}

\paragraph{Добавление опций}

Параллельно с разработкой фаз появляется необходимость дать пользователю возможность контролировать поведение трансформации. Для этого на основе проведённых во второй части исследований в компилятор добавляются:

\begin{itemize}
\item опции, контролирующие поведение фазы в целом -- в течение всей компиляции модуля;
\item прагмы, контролирующие поведение фазы на уровне циклов;
\item атрибуты функций, контролирующие поведение фазы только для конкретной процедуры.
\end{itemize}

\paragraph{Тестирование фаз}

Заключительная часть работы состоит из отладки и тестирования внесённых в компилятор изменений для повышения стабильности трансформации и проверки её применимости к различным видам кода.

\section{Существующие решения}

\indent

Прежде чем приступить к непосредственно разработке, необходимо провести анализ существующих алгоритмов в литературе и публикациях и решений в компиляторах. Стоит отметить, что сама реализация каких-либо алгоритмов в компиляторах обычно представляет собой чёрный ящик ввиду отсутсвия доступа к исходному коду. Поэтому рассматривается только пользовательский интерфейс, предоставленный для управления параметрами оптимизаций.

\subsection{Алгоритмы}

\indent

На тему предподкачки данных существует много различных публикаций, относящихся как к программной реализации предподкачки в компиляторах, так и к решениям на микроархитектурном уровне. В данной работе фокус направлен на программные методы оптимизации, однако также изучены и решения на уровне микроархитектуры, влияющие на необходимость применения компилятором трансформаций. Одно из таких решений -- добавление в процессор специального устройства (префетчера), распознающего регулярные доступы в память и делающего предподкачку. В таком случае необходимость каких-либо действий со стороны компилятора пропадает.

\subsubsection{Регулярные доступы}

\indent

% TODO: add reference to prefetch instr proposal
Добавление предподкачки для регулярных доступов является довольно простой и интуитивно понятной трансформацией. Эта оптимизация рассматривается вместе с внедрением самой инструкции для предподкачки, так как регулярные доступы имеют хорошую пространственную локальность, поэтому предподкачка в данном случае даст выигрыш, если нет дополнительных устройств в самом процессоре.

\subsubsection{Рекурсивные структуры данных}
Немного про рдс, определения, различные подходы. Агрессивные оптимизации и не очень.

\subsubsection{Косвенные доступы}

\subsection{Компиляторы}

Здесь обзор четырёх компиляторов в плане опций и прагм.

\paragraph{GCC}

Существующая фаза и опции. Ссылка на доку.

\paragraph{LLVM}

Существующая фаза и опции. В скобках: см. в таком-то модуле такого-то компилятора.

\paragraph{ICC}

Прагмы. Ссылка на документацию.

\paragraph{Oracle C/C++ Compiler}

Опции. Ссылка на документацию.

\section{Инфраструктура}

В данной работе для реализации использовалась инфраструктура проекта с открытым кодом LLVM, а также одного из его подпроектов -- Clang.

\subsection{LLVM}

Про сам проект, про фронтенд, про лит и LNT.

\subsection{Архитектура ARC}

Небольшой обзор архитектуры: embedded, конфигурируемые процессоры, широко используются в различных областях, интересный набор инструкций.

\section{Реализация}

В ходе работы были реализованы четыре фазы, каждая из которых специализируется на каком-то конкретном виде доступа к данным

\subsection{Преаллокация}

Вводные слова о том, что тут вообще происходит и кто всё придумал.

\subsubsection{Архитектурные особенности}

Немного про саму инструкцию.

\subsubsection{Алгоритм}

Подробное описание алгоритма, который я хотел имплементить, со всеми опасностями и ограничениями.

\subsubsection{Возможности для улучшения}

А здесь уже ослабление требований, введение каких-то новых прагм, атрибутов, использование анализа алиасов и т.д.

\subsection{Регулярные доступы}

Примерчики, рассказ о том, что в некоторых архитектурах оптимизация не имеет смысла из-за наличия префетчера в железе.

\subsubsection{Существующая фаза}

Небольшое описание существующей фазы и её возможностей.

\subsubsection{Добавленные возможности}

То, что конкретно я улучшил в этой фазе. Распространение на внешние циклы и добавление предподкачки перед циклом.

\subsubsection{Возможности для улучшения}

Дополнительный анализ на применимость, учёт профильной информации.

\subsection{Косвенные доступы}

Что есть косвенный доступ, почему важно.

\subsubsection{Базовый алгоритм}

Здесь рассказ об алгоритме товарищей из Кэмбриджа.

\subsubsection{Расширенная версия}

А здесь уже моя модификация и расширение этого алгоритма.

\paragraph{Поиск базовых индуктивных переменных}

\paragraph{Случаи с шагом большим единицы и неизвестным на этапе компиляции шагом}

\paragraph{Вычисление дистанции с учётом сгенерированного кода}

\subsubsection{Дальнейшие улучшения}

Анализ указателей, профильная информация, более аккуратная генерация инструкций, возможность использовать скалярную эволюцию для промежуточных вычислений, учёт давления на регистры.

\subsection{Рекурсивные структуры данных}

Рассказ о работах Тодда Маури и Ченга Люка. Определение различных типов указателей в структурах. Различные методики для предподкачки.

\subsubsection{Определение рекурсивных структур данных}

Возможно, слить с тем, что сверху, либо переделать структуру.

\subsubsection{Алгоритм}

Конкретно моя реализация.

\subsubsection{Дальнейшие улучшения}

Профильная информация, менее жадный префетч, перестановка инструкций местами.

\section{Контроль фаз}

Почему важно давать пользователю ручки.

\subsection{Опции}

Здесь про изучение опций в компиляторах.

\paragraph{Sun Compiler}

\paragraph{GCC}

\paragraph{LLVM}

\paragraph{Добавленные опции}

Мои наработки.

\subsection{Прагмы}

Здесь о прагмах.

\paragraph{ICC}

\paragraph{Добавленные прагмы}

\subsection{Аттрибуты}

Немного о том, зачем это вообще пригодилось и почему нет в других компиляторах.

\paragraph{Добавленный атрибут}

\section{Тестирование}

Что именно было важно в данной работе: отладка и применимость.

\subsection{Инфраструктура для тестирования}

Немного про тулзы, которые использовались, типа лита, метаваре тулчейна, симулятора, нативной платформы.

\paragraph{Ливерморские циклы}

Что это, чем знаменито.

\paragraph{LLVM Nightly Testsuite}

Хорошее описание, из чего состоит и зачем используется.

\paragraph{Тесты для симулятора}

Упоминание про DSP-stone и ручные тесты.

\paragraph{Юнит-тесты}

Мелкие тесты для лита и для x86 запуска.

\subsection{Применимость фаз}

Здесь красиво о количестве применений разных фаз. Предположения о том, почему так.

\subsection{Покрытие кода}

Расписать наборы тестов, почему именно такой выбор. Далее красиво, с процентиками, покрытие. Объяснение, почему хорошее, но не идеальное (по крайней мере, функциональное).

\section{Результат работы}

Здесь копия целей, но уже выполненных в результате работы.

\section{Заключение}

А вот здесь немного общих слов оценивающего характера о моей работе. После этого дальнейшие направления - улучшение статического анализа, учёт профильной информации и предподкачка кода.

\end{document}
