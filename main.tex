\documentclass[12pt,a4paper]{article}

\usepackage[top=2.0cm, bottom=2.0cm, left=3cm, right=1.5cm, footskip=0.5cm]{geometry}

\usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[T1,T2A]{fontenc}                    % Поддержка русских букв
\usepackage[utf8]{inputenc}[2014/04/30]         % Кодировка utf8
\usepackage[english, russian]{babel}[2014/03/24]% Языки: русский, английский

\usepackage{setspace}

\usepackage{array}
\usepackage{multirow}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{ucs}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
\lstset{inputencoding=utf8, extendedchars=\true}

\usepackage{amssymb}

% \spacing{1.5}
% \linespread{1.3}
\setstretch{1.25}
\begin{document}

\tableofcontents
\newpage

\section{Вступление}

\indent

% TODO: add reference: presentation EETimes
Встраиваемые системы получают всё большее распространение в современном мире. Примеры их использования можно найти почти в любой области деятельности, начиная от промышленных систем, сложной техники с множеством подобных устройств, автомобилей и летательных аппаратов и заканчивая обычными персональными устройствами наподобие мобильных телефонов или бытовой техники. В последнее время также набирает популярность интернет вещей (``Internet of Things'', IOT) -- область, связанная с использованием большого количества постоянно обменивающихся между собой информацией вычислительных устройств в самых различных направлениях деятельности.

% TODO: add reference: presentation EETimes
Развитие области применения встраиваемых систем приводит к их постепенному усложнению, так как от таких устройств требуется всё больше функциональности. Необходимость расширения функционала приводит к потребности в увеличении производительности процессоров в таких системах, что влечёт за собой изменения в архитектуре и микроархитектуре, например, к добавлению кэшей и расширению набора инструкций. Таким образом процессоры в таких устройствах становятся всё более похожими на процессоры общего назначения, поэтому открываются новые возможности для оптимизации программного обеспечения, загружаемого во встраиваемые системы.

% TODO: add reference: presentation EETimes
Расширение функционала устройств также приводит к изменениям в программном обеспечении встроенных систем. Оно становится всё более сложным и ресурсоёмким. Растёт количество строк в проектах, появляется всё больше уровней абстракции. Ручная оптимизация постепенно теряет приоритет, уступая его непосредственно написанию и проектированию сложного кода. При этом усложнение архитектуры открывает возможности для новых оптимизаций, поэтому с учётом того, что во встраиваемых системах особенно ценны ресурсы процессора, появляется необходимость в автоматическом проведении оптимизаций над кодом, например, с помощью компилятора.

% TODO: add reference: misses
Современные приложения, как для процессоров общего назначения, так и для встраиваемых систем, могут очень активно использовать память, при этом частота работы процессоров выше, чем частота работы оперативной памяти, что может повлечь за собой задежки при исполнении инструкций (проблема, известная как ``Memory wall''). Эффективным средством борьбы с ними являются кэши, но даже хорошо спроектированная многоуровневая иерархия кэшей не позволяет полностью избавиться от задержек. Промахи в кэш будут происходить как при первичных доступах к данным, так и просто при нерегулярном доступе в память (например, при обходе дерева, узлы которого выделены в куче).

% TODO: add reference: about software prefetching
В качестве одного из решений данной проблемы можно привести поддержку компилятора, анализирующего доступы в память, и вставляющего специальные инструкции предподкачки данных в кэш. Однако при таком подходе встаёт вопрос о том, как определить, где действительно нужна трансформация, а где нет, так как сгенерированный код в последнем случае либо не делает никакой полезной работы, либо загрязняет кэш, что может приводить к ухудшению производительности. В случае же успешной предподкачки исполнение программ может значительно ускоряться, показывая хорошие результаты на различных классах приложений.

\newpage

\section{Цель работы}

\indent

Главной целью данного проекта является разработка машинно-независимой оптимизирующей трансформации предподкачки данных для циклов в открытой инфраструктуре компилятора LLVM. В рамках данной работы можно выделить пять основных частей, которые, в свою очередь, также охватывают несколько различных областей в соответствующих темах. Первые две составляющие являются исследовательской работой, остальное -- сама разработка и тестирование полученной фазы.

\paragraph{Исследование алгоритмов}

В данной части необходимо исследовать нескольких подходов для различных способов работы с памятью, таких как косвенные доступы и доступы к рекурсивным структурам данных, представляющим наибольший интерес ввиду отсутвия какой-либо регулярности при доступе в память.

\paragraph{Исследование компиляторов}

Вторая часть работы должна включать в себя исследование уже существующих решений в различных компиляторах на предмет их возможностей касательно данной оптимизации, а также возможности настройки поведения фаз.

\paragraph{Разработка фаз}

Третья часть -- непосредственно разработка комплексной трансформации, состоящей из четырёх отдельных подзадач:
\begin{itemize}
\item разработка фазы архитектурно-зависимой преаллокации (только для архитектуры ARC);
\item улучшение уже существующей фазы для предподкачки данных при регулярных доступах (\textbf{``stride accesses''}) -- добавление предподкачки перед циклом и возможности предподкачки во внешних циклах;
\item разработка фазы предподкачки данных для косвенных доступов (\textbf{``indirect accesses''});
\item разработка фазы предподкачки данных для доступов в рекурсивных структурах данных (\textbf{``recursive data structures''}, \textbf{``RDS''}).
\end{itemize}

\paragraph{Добавление опций}

Параллельно с разработкой фаз появляется необходимость дать пользователю возможность контролировать поведение трансформации. Для этого на основе проведённых во второй части исследований в компилятор добавляются:

\begin{itemize}
\item опции, контролирующие поведение фазы в целом -- в течение всей компиляции модуля;
\item прагмы, контролирующие поведение фазы на уровне циклов;
\item атрибуты функций, контролирующие поведение фазы только для конкретной процедуры.
\end{itemize}

\paragraph{Тестирование фаз}

Заключительная часть работы состоит из отладки и тестирования внесённых в компилятор изменений для повышения стабильности трансформации и проверки её применимости к различным видам кода.

\section{Существующие решения}

\indent

Прежде чем приступить непосредственно к разработке, необходимо провести анализ существующих алгоритмов в литературе и публикациях и решений в современных компиляторах. Стоит отметить, что сама реализация каких-либо алгоритмов в компиляторах обычно представляет собой чёрный ящик ввиду отсутствия доступа к исходному коду. Поэтому рассматривается только пользовательский интерфейс, предоставленный для управления параметрами оптимизаций.

\subsection{Алгоритмы}

\indent

% add reference to classification
% add footnote
Перед рассмотрением самих алгоритмов предподкачки данных стоит выделить виды доступов в память, потому что методы для предподкачки данных для разных типов обращений будут существенно отличаться друг от друга. Все приложения по типу доступов в память можно классифицировать следующим образом. Во-первых, доступы в память могут быть \emph{регулярными} (например, проход по массиву) и \emph{нерегулярными} (хэш-таблицы, деревья, выделенные в куче). Во-вторых, нерегулярные доступы далее можно разделить ещё на две категории: доступ по указателям в \emph{рекурсивных структурах данных} и доступ через \emph{косвенную адресацию} (например, один массив индексируется значениями другого). Первое разбиение позволяет разделить приложения, активно использующие память, на \emph{регулярные} и \emph{нерегулярные}. Краткая сводка этой классификации дана в таблице. Аппаратные методы обозначены \textbf{HW}, программные -- \textbf{SW}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|| m{4cm} | l | l | m{5.5cm} ||}
      \hline
      Тип доступа & Пример кода & \multicolumn{2}{|l|}{Способы борьбы с задержками} \\
      \hline\hline
      \multirow{2}{4cm}{Регулярный доступ} & \texttt{a[i] = /* ... */} & HW & Потоковый буфер \\ \cline{3-4}
                  &  \texttt{a[i * 2] = /* ... */} & SW & Предподкачка массивов в циклах \\
      \hline
      Косвенный доступ & \texttt{x = a[b[i]];} & SW & Предподкачка для косвенных доступов с подгрузкой промежуточных индексов \\
      \hline
      \multirow{4}{4cm}{Рекурсивные структуры данных} & \multirow{4}{*}{\texttt{list = list->next;}} & HW & Предподкачка на основе зависимостей \\ \cline{3-4}
                  & & \multirow{3}{*}{SW} & Жадная предподкачка \\
                  & & & Предподкачка линеаризацией данных \\
                  & & & Предподкачка по запомненным указателям \\
      \hline
    \end{tabular}
    \caption{Классификация доступов в память}
    \label{tab:classify}
  \end{center}
\end{table}

На тему предподкачки данных существует много различных публикаций, относящихся как к программной реализации предподкачки в компиляторах, так и к решениям на микроархитектурном уровне. В данной работе фокус направлен на программные методы оптимизации, однако также изучены и решения на уровне микроархитектуры, влияющие на необходимость применения трансформаций компилятором.

\subsubsection{Регулярные доступы}

% TODO: add reference to prefetch instr proposal, Callahan 1991, Mowry 1992
\paragraph{Программная предподкачка данных}

Добавление предподкачки для регулярных доступов является довольно простой и интуитивно понятной трансформацией. Эта оптимизация рассматривается вместе с внедрением самой инструкции для предподкачки, так как регулярные доступы имеют хорошую пространственную локальность, поэтому предподкачка в данном случае даст выигрыш, если нет дополнительных устройств в самом процессоре. Алгоритм для такой оптимизации можно посмотреть, например, в следующих работах: %add ref.

\paragraph{Аппаратная поддержка предподкачки}

% add ref to stream buffers
Одно из решений на уровне микроархитектуры процессора -- это добавление \emph{потокового буфера} (``Stream buffer''), специального устройства, организованного в виде очереди (``FIFO buffer'') и позволяющего предподкачивать данные при промахах в кэш. При таком подходе используется свойство пространственной локальности, так как данные начинают спекулятивно подкачиваться по адресам, идущим после адреса, по которому был промах. Сам потоковый буфер стоит между кэшом первого уровня и кэшом второго уровня (или памятью), при этом процессор также соединён с буфером, чтобы у него была возможность сравнивать тэги записей. Дополнительное улучшение потокового буфера заключается в том, что делается несколько таких буферов, чтобы у них была возможность подкачивать данные из разных областей памяти одновременно (например, такое необходимо при обработке нескольких массивов в циклах). Такой буфер называется \emph{многоканальным потоковым буфером} (``Multi-way stream buffer'').

Алгоритм работы такого устройства можно описать следующим образом. Когда происходит промах в кэш первого уровня, потоковый буфер начинает последовательно подкачивать данные из кэша верхнего уровня, начиная с адреса, по которому был промах. Для каждого запроса в буфере создаётся соответствующая запись, хранящая тэг для запрашиваемого адреса. Когда данные приходят от верхнего уровня, они кладутся в буфер в соответсвии сохранённым тэгом. При этом в кэш первого уровня ничего не записывается, чтобы не загрязнять его данными, которые, возможно, не будут использованы. Затем, если процессор запрашивает данные из памяти, сравниваются тэги не только в кэше, но и в потоковом буфере. Если в потоковом буфере нашлась запись, то она перемещается в кэш, а остальные записи сдвигаются, освобождая место. При новом промахе весь буфер начинает работу заново.

\subsubsection{Рекурсивные структуры данных}

\indent

Рекурсивные структуры данных широко используются в приложениях общего назначнения. Простейшим видом такой структуры является односвязный список, каждый узел которого выделен в динамической памяти (куче). При этом все элементы, кроме последнего, ссылаются последовательно друг на друга. При обходе подобного списка в циклах получается, что при каждом доступе к узлу может происходить промах в кэше, потому что нет какой-то чёткой структуры расположения элементов списка в памяти. Другими примерами рекурсивных структур данных являются деревья и графы. Обход таких объектов осуществляется по более сложным правилам.

В данной работе исследовалось несколько способов предподкачки данных для рекурсивных структур. Один из них включает изменения в микроархитектуре и добавлении новых блоков в процессор, три других -- программные методы разной степени сложности в реализации.

\paragraph{Предподкачка на основе зависимостей (Dependence based prefetching)}

Этот метод является динамическим и реализуется на уровне микроархитектуры процессора. Во время исполнения программы анализируются чтения из памяти и на основе полученной информации строятся предположения о том, как связаны между собой адреса и инструкции. Затем из полученных данных определяется, что необходимо подкачивать в кэш для будущего использования. Таким образом этот блок распознаёт обходы рекурсивных структур данных и подкачивает следующие элементы.

Метод использует четыре новые структуры. Первые две отвечают за построение связей между инструкциями и адресами, по которым они что-либо загружают. Оставшиеся две уже непосредственно реализуют механизм предподкачки.

Построение связей между инструкциями происходит при помощи \emph{таблицы корреляции} (``Correlation Table'') и \emph{таблицы возможных производителей} (``Potential Producer Window''). Таблица корреляций содержит в себе пары счётчиков команд производителей и потребителей адреса, а также шаблон для генерации такого адреса. Чтобы эта таблица постепенно наполнялась, используется таблица возможных производителей. Каждый раз, когда завершается исполнение какой-либо инструкции чтения из памяти (то есть на стадии ``commit''), то сначала адрес, по которому происходило чтение, проверяется на наличие в ТВП, а затем туда же записывается счётчик команд и загруженный этой инструкцией значение. Таким образом, ТВП содержит в себе записи из адреса и счётчик команд. Если адрес нашёлся в ТВП, то добавляется запись в ТК.

Далее используется \emph{очередь запросов на предподкачку} (``Prefetch Request Queue''), запись в которую заносится, если после завершения инструкции чтения из памяти её адрес нашёлся в КТ. Запись в ОЗП содержит счётчик команд потребителя из соответствующей записи КТ и адрес для предподкачки, который получается применением шаблона к загруженным данным. После того, как запись сформировалась, идёт ожидание, пока освободятся порты памяти. Затем отправляется запрос на предподкачку и добавляется запись в \emph{буфер предподкачки} (``Prefetch Buffer''), который содержит в себе счётчик команд потребителя, адрес и загруженное из памяти значение. Затем при исполнении потребителя обращение идёт одновременно к кэшу и к буферу предподкачки. Если в буфере находится значение, то оно используется инструкцией, а запись используется далее для генерации следующего адреса.

% ref to mowry, chi
\paragraph{Методы поиска рекурсивных структур данных}

Переходя к программным методам предподкачки данных в случае рекурсивных структур, следует отметить, что при статическом анализе программы появляется гораздо больше информации, чем при динамическом. В первую очередь для анализа доступов к указателям в рекурсивных структурах данных при компиляции исходного кода становятся известны типы указателей. Таким образом можно гораздо проще и точнее определять рекурсивные доступы.

В литературе существует алгоритм, позволяющий определить, является ли тип рекурсивной структурой данных. В его основе лежит поиск указателей на другие структуры внутри анализируемого типа. Делается проход по полям структуры и среди них ищутся указатели или массивы. Как только находится подобный тип, начинается вычисление того, на какой тип ссылается данный указатель или объекты какого типа содержит в себе массив. Происходит постепенное разыменовывание типа, в конце концов, приводящее к получению уже не указателя, а какого-то конкретного типа. Если этот тип -- структура, то считается, что исходный анализируемый тип является рекурсивной структурой данных. В противном случае анализ продолжается на оставшихся полях. Если поля заканчиваются, то структура не рекурсивная.

\paragraph{Естественные и искусственные указатели}

Стоит обратить внимание на то, что оптимизирующие трансформации могут быть очень агрессивными и, например, довольно сильно менять исходный код, типы и расположение данных. В программных методах предподкачки для рекурсивных структур проведено достаточно много исследований, что влечёт за собой некоторое разнообразие алгоритмов для решения задачи. Среди них есть и агрессивные оптимизации, дополняющие структуры данных новыми полями.

Методы предподкачки для рекурсивных структур используют информацию, содержащуюся в самих этих объектах. То есть, например, при проходе по списку инструкция предподкачки выполняется для адреса, полученного каким-либо образом из доступного внутри структуры указателя (в данном случае из указателя на следующий элемент списка). Способ, которым такой адрес получается из исходного указателя, называется \emph{функцией получения адреса}. Формально, если $A_i$ -- текущий адрес, $d$ -- дистанция для предподкачки, достаточная, чтобы скрыть задержки, и $A_{i+d}$ -- адрес элемента, который необходимо вычислить, а $\mathcal{F}$ функция получения адреса, то:
\begin{displaymath}
  A_{i+d} = \mathcal{F}(A_i,d).
\end{displaymath}

Указатель $A_i$ называется \emph{указателем перехода} (``Jump-pointer''). Такие указатели внутри рекурсивных структур данных подразделяют на два типа. Первый тип называется \emph{естественным} (``natural''). Под естественностью этих указателей подразумевается то, что они появились в программе без участия компилятора -- только потому что сам программист определил структуры данных таким образом. Второй тип -- это \emph{искусственные} (``artificial'') указатели. Это указатели, которые появились в структуре в результате проведения каких-либо оптимизаций компилятором. Такие указатели затем используются в модифицированных процедурах, которые каким-либо образом могут использовать эту информацию или же перезаписывать значения этих новых полей. Такая классификация удобна для последующего анализа алгоритмов программной предподкачки.

\paragraph{Жадная предподкачка}

Относительно простым методом среди всех способов предподкачки доступов к рекурсивным структурам является \emph{жадная предподкачка} (``Greedy prefetching''). Её жадность заключается в том, что при анализе какого-либо участка программы, например, цикла или рекурсивных вызовов процедур, ищутся все использованные естественные указатели в структуре. Затем, в зависимости от функции получения адреса, добавляются инструкции предподкачки по полученным адресам.

Стоит заметить, что несмотря на простоту, такой подход является довольно эффективным и хорошо справляющимся с уменьшением задержек доступов в память. Например, при обходе дерева, у каждого узла которого $k$ потомков, задежка полностью пропадает при доступе к $\frac{k-1}{k}$ узлам. То есть для бинарного дерева примерно 50\% узлов будет вовремя подкачано в кэш.

\paragraph{Проблема погони за указателем}

В предыдущем алгоритме не было уточнения о том, какой именно должна быть функция $\mathcal{F}$. Обозначим количество разыменований при вычислении следующего адреса с помощью $\mathcal{F}$ как $||\mathcal{F}||$. Очевидно, что при жадной предподкачке $||\mathcal{F}||$ не может быть нулевым. Случай, когда $||\mathcal{F}|| = 1$ является довольно ожидаемым -- при таком подходе всегда предподкачиваются только ближайшие узлы (например, следующий элемент списка), так как есть только одно разыменование. Дополнительно можно заметить, что для данной схемы $||\mathcal{F}|| = d$.

Теперь остался случай, когда $||\mathcal{F}|| > 1$. То есть количество разыменований становится больше, благодаря чему появляется возможность получить, например, $i+2$-ой элемент списка при наличии только указателя на $i$-ый элемент. Однако такой подход оказывается нерабочим, так как для разыменовывания последующих указателей приходится ждать, пока подкачается предыдущий элемент. Эта проблема известна под названием \emph{проблемы погони за указателем} (``Pointer-chasing problem''). Из-за этой проблемы получается, что в более чем одном разыменовании при жадной предподкачке нет никакого смысла. Наглядное доказательство этого утверждения можно посмотреть, например, в презентации TM.

\paragraph{Предподкачка по запомненным указателям}

Следующим методом предподкачки при рекусивных доступах является \emph{предподкачка по запомненным указателям} (``History-pointer prefetching''). Этот метод пытается решить проблему погони за указателем с помощью введения дополнительного искусственного указателя в структуру данных. Этот указатель используется при обходах структуры, чтобы получать адрес необходимого для предподкачки элемента за одно разыменование. То есть при таком подходе получается, что $d > 1$ и $||\mathcal{F}|| = 0$.

Сам алгоритм отличается своей сложностью, так как требуется довольно большая работа по модификации кода программы. Во-первых, необходимо добавить в структуры особые искуственные указатели, называющиеся \emph{запоминающие указатели} (``History-pointer''). Во-вторых, потребуется добавить код для инициализации этих указателей, причём для каждого вида рекурсивной структуры данных будет собственный метод, что уже создаёт определённые сложности при анализе структур и процедур, которые их обрабатывают. В-третьих, появляется возможность того, что все указатели придётся перевязывать на другие элементы в случае модификации всего объекта.

Таким образом, предподкачка по запомненным адресам является очень эффективным методом в плане сокрытия задержек, если программа редко модифицирует рекурсивные структуры. В качестве отрицательных сторон выступают очень высокая сложность реализации, большие расходы во время исполнения при часто меняющихся объектах, на которые была применена оптимизация, и дополнительный расход памяти для содержания запоминающих указателей.

\paragraph{Предподкачка линеаризацией данных}

Последний рассмотренный в работе метод, посвящённый проблеме предподкачки для рекурсивных структур, использует в качестве функции получения адреса линейную аппроксимацию. То есть,

\begin{displaymath}
  A_{i+d} = A_i + d \times sizeof(A_0).
\end{displaymath}

Благодаря такому подходу в \emph{предподкачке линеаризацией данных} (``Data-linearization prefetching'') достигается очень грубая оценка адреса следующего элемента. При этом получается, что $||\mathcal{F}|| = 0$, то есть адрес $i+d$-го элемента вычисляется без каких-либо разыменований вообще. Данная схема опирается на факт, что элементы рекурсивной структуры данных могут быть расположены в динамической памяти примерно последовательно. Однако такое маловероятно при обычном распределении динамической памяти, поэтому появляется идея, связанная с перестановкой и уплотнением выделенных элементов для того, чтобы получить выигрыш от пространственной локальности. Однако сама процедура уплотнения может быть очень дорогой во время исполнения. Также необходимо заботиться о том, чтобы в программе не оставалось указателей на старые адреса памяти, уже не являющиеся действительными после перестановки.

% Работа товарищей из Кембриджа
\subsubsection{Косвенные доступы}

\indent

Следующей важной частью исследования является обзор алгоритмов, посвящённых проблемам предподкачки при косвенных доступах к данным. Эта тема, по сравнению с предыдущей, не получила широкого распространения, однако, учитывая то, что это один из трёх основных способов работы с памятью, она также должна быть рассмотрена в рамках данной работы.

В качестве примера для разбора взят алгоритм для косвенных доступов в циклах, в котором предподкачка идёт по нескольким массивам сразу -- и индексирующему, и индексируемому. В простом примере \texttt{ x += a[b[i]] } массив \texttt{a} -- индексируемый, массив \texttt{b} -- индексирующий. Исследование показывает, что при подобном доступе требуются две предподкачки.

\lstinputlisting[caption=Пример предподкачки для косвенного доступа в память, style=CStyle]{indirect_example.c}

Сам же алгоритм состоит из трёх основных этапов. Сначала идёт поиск в глубину всех подходящих цепочек по графу зависимости по данным. Поиск прекращается, если найдена индуктивная переменная (успешный результат, цепочка запоминается) или если найден инвариант цикла (в таком случае ничего запоминать не надо). Затем убираются лишние цепочки, усложняющие анализ. Например, цепочка со сложной зависимостью от фи-узлов или с вызовом функции будет отброшена. Затем наступает фаза генерации кода предподкачки. Начинается проход по найденным цепочкам. Для каждой инструкции загрузки из памяти копируется часть цепочки, оканчивающаяся именно этой инструкцией. Эта часть используется, чтобы сгенерировать адрес отстоящего на некоторой дистанции элемента из соответствующего массива. Затем вместо самой инструкции чтения добавляется инструкция предподкачки данных.

Более подробно алгоритм будет рассмотрен в секции, посвящённой реализации преобразований.

% kim 2002
\subsubsection{Другие методы}

\indent

Последний метод, который будет упомянут в работе, нельзя отнести ни к одной из предыдущих категорий, потому что он может покрывать различные типы доступа в память. В этом методе используется \emph{предысполнение при помощи компилятора} (``Compiler-based pre-execution''), благодаря которому происходит предподкачка данных в память.

Основным элементом в данной трансформации является \emph{срез программы} (``Program slice''), представляющий собой некоторый участок программы. Так как эта оптимизация статическая, то весь анализ происходит на уровне исходного кода, в отличие от динамических схем, просматривающих уже инструкции процессора. Интересующие участки программы анализируются на возможность \emph{срезки} (``Slicing''), то есть клонирования кода и удалению из него инструкций, модифицирующих глобальное состояние программы (например, изменения глобальных переменных или запись по указателю в динамическую память). Также в новую функцию добавляются инструкции предподкачки. Затем перед исходным участком генерируется пролог, заключающийся в инициализации по одной из схем предысполнителей, в которых будет выполняться новая функция. После участка вставляется эпилог -- завершение потоков с предподкачкой.

\subsection{Компиляторы}

\paragraph{GCC}

% https://gcc.gnu.org/projects/prefetch.html
Существующая фаза и опции. Ссылка на доку.

\paragraph{LLVM}

Существующая фаза и опции. В скобках: см. в таком-то модуле такого-то компилятора.

\paragraph{ICC}

% https://software.intel.com/en-us/node/524554
Прагмы. Ссылка на документацию.

\paragraph{Oracle C/C++ Compiler}

% https://docs.oracle.com/cd/E77782_01/html/E77788/bjapr.html Oracle® Developer Studio 12.6: C User's Guide
Опции. Ссылка на документацию.

\section{Инфраструктура}

% llvm.org
В данной работе для реализации использовалась инфраструктура проекта с открытым кодом LLVM, а также одного из его подпроектов -- Clang.

\subsection{LLVM}

Про сам проект, про фронтенд, про лит и LNT.

\subsection{Архитектура ARC}

% link to synopsys???
Небольшой обзор архитектуры: embedded, конфигурируемые процессоры, широко используются в различных областях, интересный набор инструкций.

\section{Реализация}

В ходе работы были реализованы четыре фазы, каждая из которых специализируется на каком-то конкретном виде доступа к данным

\subsection{Преаллокация}

% MIPS ISA ref
+ о мипсовом преаллоке
Вводные слова о том, что тут вообще происходит и кто всё придумал.

\subsubsection{Архитектурные особенности}

Немного про саму инструкцию.

\subsubsection{Алгоритм}

Подробное описание алгоритма, который я хотел имплементить, со всеми опасностями и ограничениями.

\subsubsection{Возможности для улучшения}

А здесь уже ослабление требований, введение каких-то новых прагм, атрибутов, использование анализа алиасов и т.д.

\subsection{Регулярные доступы}

Примерчики, рассказ о том, что в некоторых архитектурах оптимизация не имеет смысла из-за наличия префетчера в железе.

\subsubsection{Существующая фаза}

Небольшое описание существующей фазы и её возможностей.

\subsubsection{Добавленные возможности}

То, что конкретно я улучшил в этой фазе. Распространение на внешние циклы и добавление предподкачки перед циклом.

\subsubsection{Возможности для улучшения}

Дополнительный анализ на применимость, учёт профильной информации.

\subsection{Косвенные доступы}

Что есть косвенный доступ, почему важно.

\subsubsection{Базовый алгоритм}

Здесь рассказ об алгоритме товарищей из Кэмбриджа.

\subsubsection{Расширенная версия}

А здесь уже моя модификация и расширение этого алгоритма.

\paragraph{Поиск базовых индуктивных переменных}

\paragraph{Случаи с шагом большим единицы и неизвестным на этапе компиляции шагом}

\paragraph{Вычисление дистанции с учётом сгенерированного кода}

\subsubsection{Дальнейшие улучшения}

Анализ указателей, профильная информация, более аккуратная генерация инструкций, возможность использовать скалярную эволюцию для промежуточных вычислений, учёт давления на регистры.

\subsection{Рекурсивные структуры данных}

Рассказ о работах Маури и Люка. Определение различных типов указателей в структурах. Различные методики для предподкачки.

\subsubsection{Определение рекурсивных структур данных}

Возможно, слить с тем, что сверху, либо переделать структуру.

\subsubsection{Алгоритм}

Конкретно моя реализация.

\subsubsection{Дальнейшие улучшения}

Профильная информация, менее жадный префетч, перестановка инструкций местами.

\section{Контроль фаз}

Почему важно давать пользователю ручки.

\subsection{Опции}

Здесь про изучение опций в компиляторах.

\paragraph{Sun Compiler}

\paragraph{GCC}

\paragraph{LLVM}

\paragraph{Добавленные опции}

Мои наработки.

\subsection{Прагмы}

Здесь о прагмах.

\paragraph{ICC}

\paragraph{Добавленные прагмы}

\subsection{Аттрибуты}

Немного о том, зачем это вообще пригодилось и почему нет в других компиляторах.

\paragraph{Добавленный атрибут}

\section{Тестирование}

Что именно было важно в данной работе: отладка и применимость.

\subsection{Инфраструктура для тестирования}

Немного про тулзы, которые использовались, типа лита, метаваре тулчейна, симулятора, нативной платформы.

\paragraph{Ливерморские циклы}

Что это, чем знаменито.

\paragraph{LLVM Nightly Testsuite}

Хорошее описание, из чего состоит и зачем используется.

\paragraph{Тесты для симулятора}

Упоминание про DSP-stone и ручные тесты.

\paragraph{Юнит-тесты}

Мелкие тесты для лита и для x86 запуска.

\subsection{Применимость фаз}

Здесь красиво о количестве применений разных фаз. Предположения о том, почему так.

\subsection{Покрытие кода}

Расписать наборы тестов, почему именно такой выбор. Далее красиво, с процентиками, покрытие. Объяснение, почему хорошее, но не идеальное (по крайней мере, функциональное).

\section{Результат работы}

Здесь копия целей, но уже выполненных в результате работы.

\section{Заключение}

А вот здесь немного общих слов оценивающего характера о моей работе. После этого дальнейшие направления - улучшение статического анализа, учёт профильной информации и предподкачка кода.

\end{document}
