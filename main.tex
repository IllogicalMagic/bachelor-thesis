\documentclass[12pt,a4paper]{article}

\usepackage[top=2.0cm, bottom=2.0cm, left=3cm, right=1.5cm, footskip=0.5cm]{geometry}

\usepackage{cmap}                               % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage[T1,T2A]{fontenc}                    % Поддержка русских букв
\usepackage[utf8]{inputenc}[2014/04/30]         % Кодировка utf8
\usepackage[english, russian]{babel}[2014/03/24]% Языки: русский, английский

\usepackage{setspace}

\usepackage{array}
\usepackage{multirow}

\usepackage{listings}

% \spacing{1.5}
% \linespread{1.3}
\setstretch{1.25}
\begin{document}

% Если содержание расползётся на две страницы
% \doublespacing
\tableofcontents
% \singlespacing
\newpage

\section{Вступление}

\indent

% TODO: add reference: presentation EETimes
Встраиваемые системы получают всё большее распространение в современном мире. Примеры их использования можно найти почти в любой области деятельности, начиная от промышленных систем, сложной техники с множеством подобных устройств, автомобилей и летательных аппаратов и заканчивая обычными персональными устройствами наподобие мобильных телефонов или бытовой техники. В последнее время также набирает популярность интернет вещей (``Internet of Things'', IOT) -- область, связанная с использованием большого количества постоянно обменивающихся между собой информацией вычислительных устройств в самых различных направлениях деятельности.

% TODO: add reference: presentation EETimes
Развитие области применения встраиваемых систем приводит к их постепенному усложнению, так как от таких устройств требуется всё больше функциональности. Необходимость расширения функционала приводит к потребности в увеличении производительности процессоров в таких системах, что влечёт за собой изменения в архитектуре и микроархитектуре, например, к добавлению кэшей и расширению набора инструкций. Таким образом процессоры в таких устройствах становятся всё более похожими на процессоры общего назначения, поэтому открываются новые возможности для оптимизации программного обеспечения, загружаемого во встраиваемые системы.

% TODO: add reference: presentation EETimes
Расширение функционала устройств также приводит к изменениям в программном обеспечении встроенных систем. Оно становится всё более сложным и ресурсоёмким. Растёт количество строк в проектах, появляется всё больше уровней абстракции. Ручная оптимизация постепенно теряет приоритет, уступая его непосредственно написанию и проектированию сложного кода. При этом усложнение архитектуры открывает возможности для новых оптимизаций, поэтому с учётом того, что во встраиваемых системах особенно ценны ресурсы процессора, появляется необходимость в автоматическом проведении оптимизаций над кодом, например, с помощью компилятора.

% TODO: add reference: misses
Современные приложения, как для процессоров общего назначения, так и для встраиваемых систем, могут очень активно использовать память, при этом частота работы процессоров выше, чем частота работы оперативной памяти, что может повлечь за собой задежки при исполнении инструкций (проблема, известная как ``Memory wall''). Эффективным средством борьбы с ними являются кэши, но даже хорошо спроектированная многоуровневая иерархия кэшей не позволяет полностью избавиться от задержек. Промахи в кэш будут происходить как при первичных доступах к данным, так и просто при нерегулярном доступе в память (например, при обходе дерева, узлы которого выделены в куче).

% TODO: add reference: about software prefetching
В качестве одного из решений данной проблемы можно привести поддержку компилятора, анализирующего доступы в память, и вставляющего специальные инструкции предподкачки данных в кэш. Однако при таком подходе встаёт вопрос о том, как определить, где действительно нужна трансформация, а где нет, так как сгенерированный код в последнем случае либо не делает никакой полезной работы, либо загрязняет кэш, что может приводить к ухудшению производительности. В случае же успешной предподкачки исполнение программ может значительно ускоряться, показывая хорошие результаты на различных классах приложений.

\newpage

\section{Цель работы}

\indent

Главной целью данного проекта является разработка машинно-независимой оптимизирующей трансформации предподкачки данных для циклов в открытой инфраструктуре компилятора LLVM. В рамках данной работы можно выделить пять основных частей, которые, в свою очередь, также охватывают несколько различных областей в соответствующих темах. Первые две составляющие являются исследовательской работой, остальное -- сама разработка и тестирование полученной фазы.

\paragraph{Исследование алгоритмов}

В данной части необходимо исследовать нескольких подходов для различных способов работы с памятью, таких как косвенные доступы и доступы к рекурсивным структурам данных, представляющим наибольший интерес ввиду отсутвия какой-либо регулярности при доступе в память.

\paragraph{Исследование компиляторов}

Вторая часть работы должна включать в себя исследование уже существующих решений в различных компиляторах на предмет их возможностей касательно данной оптимизации, а также возможности настройки поведения фаз.

\paragraph{Разработка фаз}

Третья часть -- непосредственно разработка комплексной трансформации, состоящей из четырёх отдельных подзадач:
\begin{itemize}
\item разработка фазы архитектурно-зависимой преаллокации (только для архитектуры ARC);
\item улучшение уже существующей фазы для предподкачки данных при регулярных доступах (\textbf{``stride accesses''}) -- добавление предподкачки перед циклом и возможности предподкачки во внешних циклах;
\item разработка фазы предподкачки данных для косвенных доступов (\textbf{``indirect accesses''});
\item разработка фазы предподкачки данных для доступов в рекурсивных структурах данных (\textbf{``recursive data structures''}, \textbf{``RDS''}).
\end{itemize}

\paragraph{Добавление опций}

Параллельно с разработкой фаз появляется необходимость дать пользователю возможность контролировать поведение трансформации. Для этого на основе проведённых во второй части исследований в компилятор добавляются:

\begin{itemize}
\item опции, контролирующие поведение фазы в целом -- в течение всей компиляции модуля;
\item прагмы, контролирующие поведение фазы на уровне циклов;
\item атрибуты функций, контролирующие поведение фазы только для конкретной процедуры.
\end{itemize}

\paragraph{Тестирование фаз}

Заключительная часть работы состоит из отладки и тестирования внесённых в компилятор изменений для повышения стабильности трансформации и проверки её применимости к различным видам кода.

\section{Существующие решения}

\indent

Прежде чем приступить непосредственно к разработке, необходимо провести анализ существующих алгоритмов в литературе и публикациях и решений в современных компиляторах. Стоит отметить, что сама реализация каких-либо алгоритмов в компиляторах обычно представляет собой чёрный ящик ввиду отсутствия доступа к исходному коду. Поэтому рассматривается только пользовательский интерфейс, предоставленный для управления параметрами оптимизаций.

\subsection{Алгоритмы}

\indent

% add reference to classification
% add footnote
Перед рассмотрением самих алгоритмов предподкачки данных стоит выделить виды доступов в память, потому что методы для предподкачки данных для разных типов обращений будут существенно отличаться друг от друга. Все приложения по типу доступов в память можно классифицировать следующим образом. Во-первых, доступы в память могут быть \emph{регулярными} (например, проход по массиву) и \emph{нерегулярными} (хэш-таблицы, деревья, выделенные в куче). Во-вторых, нерегулярные доступы далее можно разделить ещё на две категории: доступ по указателям в \emph{рекурсивных структурах данных} и доступ через \emph{косвенную адресацию} (например, один массив индексируется значениями другого). Первое разбиение позволяет разделить приложения, активно использующие память, на \emph{регулярные} и \emph{нерегулярные}. Краткая сводка этой классификации дана в таблице. Аппаратные методы обозначены \textbf{HW}, программные -- \textbf{SW}.

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|| m{4cm} | l | l | m{5.5cm} ||}
      \hline
      Тип доступа & Пример кода & \multicolumn{2}{|l|}{Способы борьбы с задержками} \\
      \hline\hline
      \multirow{2}{4cm}{Регулярный доступ} & \texttt{a[i] = /* ... */} & HW & Потоковый буфер \\ \cline{3-4}
                  &  \texttt{a[i * 2] = /* ... */} & SW & Предподкачка массивов в циклах \\
      \hline
      Косвенный доступ & \texttt{x = a[b[i]];} & SW & Предподкачка для косвенных доступов с подгрузкой промежуточных индексов \\
      \hline
      \multirow{4}{4cm}{Рекурсивные структуры данных} & \multirow{4}{*}{\texttt{list = list->next}} & HW & Предподкачка по зависимостям \\ \cline{3-4}
                  & & \multirow{3}{*}{SW} & Жадная предподкачка \\
                  & & & Линеаризация данных \\
                  & & & Jump pointers \\
      \hline
    \end{tabular}
    \caption{Классификация доступов в память}
    \label{tab:classify}
  \end{center}
\end{table}

На тему предподкачки данных существует много различных публикаций, относящихся как к программной реализации предподкачки в компиляторах, так и к решениям на микроархитектурном уровне. В данной работе фокус направлен на программные методы оптимизации, однако также изучены и решения на уровне микроархитектуры, влияющие на необходимость применения трансформаций компилятором.

\subsubsection{Регулярные доступы}

% TODO: add reference to prefetch instr proposal, Callahan 1991, Mowry 1992
\paragraph{Программная предподкачка данных}

Добавление предподкачки для регулярных доступов является довольно простой и интуитивно понятной трансформацией. Эта оптимизация рассматривается вместе с внедрением самой инструкции для предподкачки, так как регулярные доступы имеют хорошую пространственную локальность, поэтому предподкачка в данном случае даст выигрыш, если нет дополнительных устройств в самом процессоре. Алгоритм для такой оптимизации можно посмотреть, например, в следующих работах: %add ref.

\paragraph{Аппаратная поддержка предподкачки}

% add ref to stream buffers
Одно из решений на уровне микроархитектуры процессора -- это добавление \emph{потокового буфера} (``Stream buffer''), специального устройства, организованного в виде очереди (``FIFO buffer'') и позволяющего предподкачивать данные при промахах в кэш. При таком подходе используется свойство пространственной локальности, так как данные начинают спекулятивно подкачиваться с линий, идущих после адреса, по которому был промах. Сам потоковый буфер стоит между кэшом первого уровня и кэшом второго уровня (или памятью), при этом процессор также соединён с буфером, чтобы у него была возможность сравнивать тэги записей. Дополнительное улучшение потокового буфера заключается в том, что делается несколько таких буферов, чтобы у них была возможность подкачивать данные из разных областей памяти одновременно (например, такое необходимо при обработке нескольких массивов в циклах). Такой буфер называется \emph{многоканальным потоковым буфером} (``Multi-way stream buffer'').

Алгоритм работы такого устройства можно описать следующим образом. Когда происходит промах в кэш первого уровня, потоковый буфер начинает последовательно подкачивать данные из кэша верхнего уровня, начиная с адреса, по которому был промах. Для каждого запроса в буфере создаётся соответствующая запись, хранящая тэг для запрашиваемого адреса. Когда данные приходят от верхнего уровня, они кладутся в буфер в соответсвии сохранённым тэгом. При этом в кэш первого уровня ничего не записывается, чтобы не загрязнять его данными, которые, возможно, не будут использованы. Затем, если процессор запрашивает данные из памяти, сравниваются тэги не только в кэше, но и в потоковом буфере. Если в потоковом буфере нашлась запись, то она перемещается в кэш, а остальные записи сдвигаются, освобождая место. При новом промахе весь буфер начинает работу заново.

\subsubsection{Рекурсивные структуры данных}

Что такое рекурсивная структура данных

Dependency based prefetch for RDS -- динамическая схема для предподкачки. Использует четыре дополнительные таблицы на микроархитектурном уровне для определения, что происходит обход рекурсивной структуры данных, и предподкачки по заранее подгруженному адресу следующего элемента такой структуры

Correlation Table (CT) -- содержит PC потребителя и производителя + шаблон генерации адреса
Potential Producer Window (PPW) -- содержит адрес и PC инструкции загрузки, каждая загрузка проверяется во время коммита и если её адрес есть в PPW, то добавляется запись в CT. При этом на каждой загрузке добавляется запись в PPW.

Prefetch Request Queue (PRQ) -- очередь с запросами на предподкачку -- содержит адрес инструкции и адрес, по которому происходит загрузка
Prefetch Buffer (PB) -- буфер, содержащий предподкачанное значение, чтобы не занимать место в кэше.

% ref to mowry, chi
SW:
Методы поиска рекурсивных структур данных
Естественные и искусственные указатели
Jump pointers

Линеаризация

Жадная предподкачка
Немного про рдс, определения, различные подходы. Агрессивные оптимизации и не очень.

\subsubsection{Косвенные доступы}
Работа товарищей из Кембриджа

\subsubsection{Другие методы}
% kim 2002
Pre-execution

\subsection{Компиляторы}

Здесь обзор четырёх компиляторов в плане опций и прагм.

\paragraph{GCC}

% https://gcc.gnu.org/projects/prefetch.html
Существующая фаза и опции. Ссылка на доку.

\paragraph{LLVM}

Существующая фаза и опции. В скобках: см. в таком-то модуле такого-то компилятора.

\paragraph{ICC}

% https://software.intel.com/en-us/node/524554
Прагмы. Ссылка на документацию.

\paragraph{Oracle C/C++ Compiler}

% https://docs.oracle.com/cd/E77782_01/html/E77788/bjapr.html Oracle® Developer Studio 12.6: C User's Guide
Опции. Ссылка на документацию.

\section{Инфраструктура}

% llvm.org
В данной работе для реализации использовалась инфраструктура проекта с открытым кодом LLVM, а также одного из его подпроектов -- Clang.

\subsection{LLVM}

Про сам проект, про фронтенд, про лит и LNT.

\subsection{Архитектура ARC}

% link to synopsys???
Небольшой обзор архитектуры: embedded, конфигурируемые процессоры, широко используются в различных областях, интересный набор инструкций.

\section{Реализация}

В ходе работы были реализованы четыре фазы, каждая из которых специализируется на каком-то конкретном виде доступа к данным

\subsection{Преаллокация}

% MIPS ISA ref
+ о мипсовом преаллоке
Вводные слова о том, что тут вообще происходит и кто всё придумал.

\subsubsection{Архитектурные особенности}

Немного про саму инструкцию.

\subsubsection{Алгоритм}

Подробное описание алгоритма, который я хотел имплементить, со всеми опасностями и ограничениями.

\subsubsection{Возможности для улучшения}

А здесь уже ослабление требований, введение каких-то новых прагм, атрибутов, использование анализа алиасов и т.д.

\subsection{Регулярные доступы}

Примерчики, рассказ о том, что в некоторых архитектурах оптимизация не имеет смысла из-за наличия префетчера в железе.

\subsubsection{Существующая фаза}

Небольшое описание существующей фазы и её возможностей.

\subsubsection{Добавленные возможности}

То, что конкретно я улучшил в этой фазе. Распространение на внешние циклы и добавление предподкачки перед циклом.

\subsubsection{Возможности для улучшения}

Дополнительный анализ на применимость, учёт профильной информации.

\subsection{Косвенные доступы}

Что есть косвенный доступ, почему важно.

\subsubsection{Базовый алгоритм}

Здесь рассказ об алгоритме товарищей из Кэмбриджа.

\subsubsection{Расширенная версия}

А здесь уже моя модификация и расширение этого алгоритма.

\paragraph{Поиск базовых индуктивных переменных}

\paragraph{Случаи с шагом большим единицы и неизвестным на этапе компиляции шагом}

\paragraph{Вычисление дистанции с учётом сгенерированного кода}

\subsubsection{Дальнейшие улучшения}

Анализ указателей, профильная информация, более аккуратная генерация инструкций, возможность использовать скалярную эволюцию для промежуточных вычислений, учёт давления на регистры.

\subsection{Рекурсивные структуры данных}

Рассказ о работах Тодда Маури и Ченга Люка. Определение различных типов указателей в структурах. Различные методики для предподкачки.

\subsubsection{Определение рекурсивных структур данных}

Возможно, слить с тем, что сверху, либо переделать структуру.

\subsubsection{Алгоритм}

Конкретно моя реализация.

\subsubsection{Дальнейшие улучшения}

Профильная информация, менее жадный префетч, перестановка инструкций местами.

\section{Контроль фаз}

Почему важно давать пользователю ручки.

\subsection{Опции}

Здесь про изучение опций в компиляторах.

\paragraph{Sun Compiler}

\paragraph{GCC}

\paragraph{LLVM}

\paragraph{Добавленные опции}

Мои наработки.

\subsection{Прагмы}

Здесь о прагмах.

\paragraph{ICC}

\paragraph{Добавленные прагмы}

\subsection{Аттрибуты}

Немного о том, зачем это вообще пригодилось и почему нет в других компиляторах.

\paragraph{Добавленный атрибут}

\section{Тестирование}

Что именно было важно в данной работе: отладка и применимость.

\subsection{Инфраструктура для тестирования}

Немного про тулзы, которые использовались, типа лита, метаваре тулчейна, симулятора, нативной платформы.

\paragraph{Ливерморские циклы}

Что это, чем знаменито.

\paragraph{LLVM Nightly Testsuite}

Хорошее описание, из чего состоит и зачем используется.

\paragraph{Тесты для симулятора}

Упоминание про DSP-stone и ручные тесты.

\paragraph{Юнит-тесты}

Мелкие тесты для лита и для x86 запуска.

\subsection{Применимость фаз}

Здесь красиво о количестве применений разных фаз. Предположения о том, почему так.

\subsection{Покрытие кода}

Расписать наборы тестов, почему именно такой выбор. Далее красиво, с процентиками, покрытие. Объяснение, почему хорошее, но не идеальное (по крайней мере, функциональное).

\section{Результат работы}

Здесь копия целей, но уже выполненных в результате работы.

\section{Заключение}

А вот здесь немного общих слов оценивающего характера о моей работе. После этого дальнейшие направления - улучшение статического анализа, учёт профильной информации и предподкачка кода.

\end{document}
